# Что такое промис?
- Объект-обёртка для асинхронного кода.  
- Объект, который возвращают асинхронные функции.

# Состояния промиса
- Промис содержит состояние.
- Состояние бывает трех видов:
  - pending: ожидание, состояние до или в процессе выполнения;
  - fulfilled: выполнено успешно;
  - rejected: выполнено с ошибкой;
- Состояние можно поменять только один раз: перейти из pending в fulfilled или rejected.

# Как создать промис?
```
const new = new Promise (resolve, reject) {
  // Пример кода
  if(a === 0) {
    resolve("Ok!")
  } else {
    reject("Dont ok!")
  }
}
```

# Аргументы промиса (resolve, reject)
- resolve — колбэк для перевода промиса в состояние fulfilled, при его вызове аргументом передаётся результат операции.
- reject — колбэк для перевода промиса в состояние rejected, при его вызове аргументом передаётся информация об ошибке

# Методы промиса
- __then__  
Метод, вызываемый при переводе промиса в fullfiled.  
- __catch__  
Метод, вызываемый при переводе промиса в rejected.
- __finally__  
Метод, вызывающийся вне зависимости от результатов выполнения промиса.
- __Promise.all__  
Статический метод, вызывающийся для обработки массива промисов и выполняющийся только в случае успешного выполнения всех промисов, переданных в массиве.
- __Promise.allSettled__  
Статический метод, вызывающийся для обработки массива промисов и выполняющийся даже в том случае, если отдельные или все промисы, переданные в массиве, будут выполнены неуспешно.
- __Promise.race__  
Статический вытод, вызывающийся для обработки массива промисов и дожидающийся выполнения лишь самого быстрого промиса из массива, даже если он будет выполнен неуспешно. Остальные - игнорируются.
- __Promice.any__
Статический метод, вызывающийся для обработки массива промисов и дожидающийся первого успешно выполненного промиса. Остальные - игнорируются.

# then
- Метод промиса, который используется, чтобы выполнить код после успешного выполнения асинхронной операции.  
- Всегда возвращает новый промис.
- Принимает два аргумента:
  - onFulfill — функция-колбэк, которая будет вызвана при переходе промиса в состояние «успех» fulfilled.  
  Функция имеет один параметр, в который передаётся результат выполнения операции.
  - onReject — функция-колбэк, которая будет вызвана при переходе промиса в состояние «ошибка» rejected.  
  Функция имеет один параметр, в который передаётся информация об ошибке.  
  На практике данная функция не используется и не передается в аргумент. Ошибки обрабатываются через метод catch.

# catch
- Используется, чтобы выполнить код в случае ошибки при выполнении асинхронной операции. Т.е. если асинхронная операция:
  - вызывает функцию reject внутри промиса;
  - выбрасывает ошибку с помощью throw; 
- Обрабатывает все ошибки в вышестоящей цепочке вызовов вплоть до предыдущего catch. Если выше нет catch - до начала промиса.
- Возвращает промис.
- Принимает один аргумент:
  - onReject — функция-колбэк, которая будет вызвана при переходе промиса в состояние «ошибка» rejected.  
  Функция имеет один параметр, в который передаётся информация об ошибке.

# finally
- Используется, чтобы выполнить код при завершении промиса.
- Выполнится вне зависимости от того, была ли операция успешной или завершилась ошибкой.
- Обычно такой код занимается уборкой после операции — скрывает индикаторы загрузки, закрывает меню и т.д.
- Возвращает новый промис.
- Метод принимает один аргумент:
  - onDone — функция-колбэк, которая будет вызвана при завершении промиса.  
  Колбэк у finally не содержит параметров. Это следствие того, что колбэк будет вызван как при успехе, так и при ошибке.

# Promise.all
- Статический метод объекта promise.  
?! Поэтому при обращении к методу мы не создаем экземпляр объекта через new, а обращаемся напрямую к методу объекта через `Promise.all`.
- Используется, когда нужно запустить несколько промисов параллельно и дождаться положительного выполнения каждого из них.
- Принимает в качестве аргумента массив промисов (может любую другую итерируемую коллекцию) и возвращает новый промис, который будет fullfiled только в том случае, когда и если ВСЕ переданные в массиве промисы будут fullfiled. В противном случае будет rejected.
  - В качестве аргументов могут выступать не только промисы. Однако в этом случае при обработке они будут переделаны в Promise с состоянием fullfiled.
- Возвращает массив значений всех переданных промисов с сохранением порядка оригинального (переданного) массива. При этом выполнение самих промисов производится в произвольном порядке.
- Синтаксис:
  ```
  const a = new Promise ((resolve, reject) => {
    setTimeout(() => resolve('a'), 5000);
  });

  const b = new Promise ((resolve, reject) => {
    setTimeout(() => resolve('b'), 3000);
  });

  const c = new Promise ((resolve, reject) => {
    setTimeout(() => resolve('c'), 1000);
  });

  Promise.all([a,b,c])
    .then((arr) => {
      console.log(arr)
    }
  );
  ```

# Promise.allSettled()
- Метод идентичен методу Promise.all со следующими отличиями:
  - Переходит в fullfiled даже в том случае, если переданные промисы будут переведены в rejected;
  - Возвращает массив с результатами выполнения промисов из переданного аргументом массива, при этом каждый элемент массива будет представлять собой объект, содержащий:
    - fullfiled-промис
      ```
      { status: 'fulfilled', value: 'a' }
      ```
    - rejected-промис
      ```
      { status: 'rejected', reason: 'b' }
      ```
  - Удобен для запросов к API, когда запросы независимы и ошибка в одном не влияет на другие.

# Promise.race()
- Статический метод объекта promise.  
  ?! Поэтому при обращении к методу мы не создаем экземпляр объекта через new, а обращаемся напрямую к методу объекта через `Promise.race`.
- Используется, когда нужно запустить несколько промисов параллельно и дождаться выполнения одного из них - самого быстрого. Остальные при этом будут проигнорированы.
- Принимает в качестве аргумента массив промисов (может любую другую итерируемую коллекцию) и возвращает новый промис, который в состоянии fullfiled будет содержать результат выполнения самого быстрого промиса.
- В случае, если самый быстрый промис содержит ошибку, новый промис будет переведен в состояние rejected (т.е. не будет дожидаться успешного завершения следующего промиса).
- Синтаксис:
  ```
  const a = new Promise ((resolve, reject) => {
    setTimeout(() => resolve('a'), 5000);
  });

  const b = new Promise ((resolve, reject) => {
    setTimeout(() => resolve('b'), 3000);
  });

  const c = new Promise ((resolve, reject) => {
    setTimeout(() => resolve('c'), 1000);
  });

  Promise.race([a,b,c])
    .then((fastest) => {
      console.log(fastest)
    })
    .catch((err) => console.log(err))
  ```

# Promise.any
- Метод идентичен методу Promise.race со следующими отличиями:
  - В случае, если самый быстрый промис окажется в состоянии rejected, метод не переведет промис в rejected, а перейдет к ближайшему fullfiled-промису и перейдет в состояние fullfiled.